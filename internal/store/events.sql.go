// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: events.sql

package store

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const checkSpecificTimeslotAvailability = `-- name: CheckSpecificTimeslotAvailability :one
WITH service_info AS (
    SELECT s.duration, s.buffer_time
    FROM services s
    WHERE s.id = $4
),
user_can_provide AS (
    SELECT 1
    FROM user_services us
    WHERE us.user_id = $1
      AND us.service_id = $4
)
SELECT
    COALESCE(
        EXISTS (SELECT 1 FROM user_can_provide)
        AND NOT EXISTS (
            SELECT 1
            FROM events b
            WHERE b.user_id = $1
              AND (
                  (b.start_time < $2 AND b.end_time > $3)
                  OR (b.start_time < ($2 + (INTERVAL '1 minute' * si.buffer_time))
                      AND b.end_time > $3)
              )
        ),
        ($1 IS NULL)
    ) AS is_available
FROM service_info si
`

type CheckSpecificTimeslotAvailabilityParams struct {
	UserID    int64     `json:"userId"`
	EndTime   time.Time `json:"endTime"`
	StartTime time.Time `json:"startTime"`
	ServiceID uuid.UUID `json:"serviceId"`
}

func (q *Queries) CheckSpecificTimeslotAvailability(ctx context.Context, arg CheckSpecificTimeslotAvailabilityParams) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, checkSpecificTimeslotAvailability,
		arg.UserID,
		arg.EndTime,
		arg.StartTime,
		arg.ServiceID,
	)
	var is_available interface{}
	err := row.Scan(&is_available)
	return is_available, err
}

const createEvent = `-- name: CreateEvent :one
INSERT INTO events (
  customer_id,
  service_id,
  user_id,
  brand_id,
  start_time,
  end_time,
  comment,
  customer_name,
  service_name,
  user_name,
  cost,
  buffer_time,
  created_at,
  updated_at
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, NOW(), NOW()
) RETURNING id, customer_id, service_id, user_id, brand_id, start_time, end_time, customer_name, service_name, user_name, comment, buffer_time, cost, created_at, updated_at
`

type CreateEventParams struct {
	CustomerID   int64          `json:"customerId"`
	ServiceID    uuid.UUID      `json:"serviceId"`
	UserID       int64          `json:"userId"`
	BrandID      int32          `json:"brandId"`
	StartTime    time.Time      `json:"startTime"`
	EndTime      time.Time      `json:"endTime"`
	Comment      sql.NullString `json:"comment"`
	CustomerName string         `json:"customerName"`
	ServiceName  string         `json:"serviceName"`
	UserName     string         `json:"userName"`
	Cost         sql.NullString `json:"cost"`
	BufferTime   sql.NullInt32  `json:"bufferTime"`
}

func (q *Queries) CreateEvent(ctx context.Context, arg CreateEventParams) (*Event, error) {
	row := q.db.QueryRowContext(ctx, createEvent,
		arg.CustomerID,
		arg.ServiceID,
		arg.UserID,
		arg.BrandID,
		arg.StartTime,
		arg.EndTime,
		arg.Comment,
		arg.CustomerName,
		arg.ServiceName,
		arg.UserName,
		arg.Cost,
		arg.BufferTime,
	)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.ServiceID,
		&i.UserID,
		&i.BrandID,
		&i.StartTime,
		&i.EndTime,
		&i.CustomerName,
		&i.ServiceName,
		&i.UserName,
		&i.Comment,
		&i.BufferTime,
		&i.Cost,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const deleteEvent = `-- name: DeleteEvent :exec
DELETE FROM events
WHERE id = $1
`

func (q *Queries) DeleteEvent(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteEvent, id)
	return err
}

const getEventByID = `-- name: GetEventByID :one
SELECT id, customer_id, service_id, user_id, brand_id, start_time, end_time, customer_name, service_name, user_name, comment, buffer_time, cost, created_at, updated_at FROM events b WHERE id = $1
`

func (q *Queries) GetEventByID(ctx context.Context, id int64) (*Event, error) {
	row := q.db.QueryRowContext(ctx, getEventByID, id)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.ServiceID,
		&i.UserID,
		&i.BrandID,
		&i.StartTime,
		&i.EndTime,
		&i.CustomerName,
		&i.ServiceName,
		&i.UserName,
		&i.Comment,
		&i.BufferTime,
		&i.Cost,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getEventsByDay = `-- name: GetEventsByDay :many
SELECT id, customer_id, service_id, user_id, brand_id, start_time, end_time, customer_name, service_name, user_name, comment, buffer_time, cost, created_at, updated_at
FROM events
WHERE DATE(start_time) = $1
AND brand_id = $2
ORDER BY start_time ASC
`

type GetEventsByDayParams struct {
	StartTime time.Time `json:"startTime"`
	BrandID   int32     `json:"brandId"`
}

func (q *Queries) GetEventsByDay(ctx context.Context, arg GetEventsByDayParams) ([]*Event, error) {
	rows, err := q.db.QueryContext(ctx, getEventsByDay, arg.StartTime, arg.BrandID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.ServiceID,
			&i.UserID,
			&i.BrandID,
			&i.StartTime,
			&i.EndTime,
			&i.CustomerName,
			&i.ServiceName,
			&i.UserName,
			&i.Comment,
			&i.BufferTime,
			&i.Cost,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventsByWeek = `-- name: GetEventsByWeek :many
SELECT id, customer_id, service_id, user_id, brand_id, start_time, end_time, customer_name, service_name, user_name, comment, buffer_time, cost, created_at, updated_at
FROM events
WHERE DATE(start_time) BETWEEN $1 AND $2
AND brand_id = $3
ORDER BY start_time ASC
`

type GetEventsByWeekParams struct {
	StartDate time.Time `json:"startDate"`
	EndDate   time.Time `json:"endDate"`
	BrandID   int32     `json:"brandId"`
}

func (q *Queries) GetEventsByWeek(ctx context.Context, arg GetEventsByWeekParams) ([]*Event, error) {
	rows, err := q.db.QueryContext(ctx, getEventsByWeek, arg.StartDate, arg.EndDate, arg.BrandID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.ServiceID,
			&i.UserID,
			&i.BrandID,
			&i.StartTime,
			&i.EndTime,
			&i.CustomerName,
			&i.ServiceName,
			&i.UserName,
			&i.Comment,
			&i.BufferTime,
			&i.Cost,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserEventsByDay = `-- name: GetUserEventsByDay :many
SELECT id, customer_id, service_id, user_id, brand_id, start_time, end_time, customer_name, service_name, user_name, comment, buffer_time, cost, created_at, updated_at
FROM events
WHERE DATE(start_time) = $1
AND brand_id = $2
AND user_id = $3
ORDER BY start_time ASC
`

type GetUserEventsByDayParams struct {
	StartTime time.Time `json:"startTime"`
	BrandID   int32     `json:"brandId"`
	UserID    int64     `json:"userId"`
}

func (q *Queries) GetUserEventsByDay(ctx context.Context, arg GetUserEventsByDayParams) ([]*Event, error) {
	rows, err := q.db.QueryContext(ctx, getUserEventsByDay, arg.StartTime, arg.BrandID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.ServiceID,
			&i.UserID,
			&i.BrandID,
			&i.StartTime,
			&i.EndTime,
			&i.CustomerName,
			&i.ServiceName,
			&i.UserName,
			&i.Comment,
			&i.BufferTime,
			&i.Cost,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserEventsByWeek = `-- name: GetUserEventsByWeek :many
SELECT id, customer_id, service_id, user_id, brand_id, start_time, end_time, customer_name, service_name, user_name, comment, buffer_time, cost, created_at, updated_at
FROM events
WHERE DATE(start_time) BETWEEN $1 AND $2
AND brand_id = $3
AND user_id = $4
ORDER BY start_time ASC
`

type GetUserEventsByWeekParams struct {
	StartDate time.Time `json:"startDate"`
	EndDate   time.Time `json:"endDate"`
	BrandID   int32     `json:"brandId"`
	UserID    int64     `json:"userId"`
}

func (q *Queries) GetUserEventsByWeek(ctx context.Context, arg GetUserEventsByWeekParams) ([]*Event, error) {
	rows, err := q.db.QueryContext(ctx, getUserEventsByWeek,
		arg.StartDate,
		arg.EndDate,
		arg.BrandID,
		arg.UserID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.ServiceID,
			&i.UserID,
			&i.BrandID,
			&i.StartTime,
			&i.EndTime,
			&i.CustomerName,
			&i.ServiceName,
			&i.UserName,
			&i.Comment,
			&i.BufferTime,
			&i.Cost,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEventsByBrand = `-- name: ListEventsByBrand :many
SELECT id, customer_id, service_id, user_id, brand_id, start_time, end_time, customer_name, service_name, user_name, comment, buffer_time, cost, created_at, updated_at FROM events
WHERE brand_id = $1
ORDER BY start_time
LIMIT $2
OFFSET $3
`

type ListEventsByBrandParams struct {
	BrandID int32 `json:"brandId"`
	Limit   int32 `json:"limit"`
	Offset  int32 `json:"offset"`
}

func (q *Queries) ListEventsByBrand(ctx context.Context, arg ListEventsByBrandParams) ([]*Event, error) {
	rows, err := q.db.QueryContext(ctx, listEventsByBrand, arg.BrandID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.ServiceID,
			&i.UserID,
			&i.BrandID,
			&i.StartTime,
			&i.EndTime,
			&i.CustomerName,
			&i.ServiceName,
			&i.UserName,
			&i.Comment,
			&i.BufferTime,
			&i.Cost,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEventsByCustomer = `-- name: ListEventsByCustomer :many
SELECT id, customer_id, service_id, user_id, brand_id, start_time, end_time, customer_name, service_name, user_name, comment, buffer_time, cost, created_at, updated_at FROM events
WHERE customer_id = $1
ORDER BY start_time
LIMIT $2
OFFSET $3
`

type ListEventsByCustomerParams struct {
	CustomerID int64 `json:"customerId"`
	Limit      int32 `json:"limit"`
	Offset     int32 `json:"offset"`
}

func (q *Queries) ListEventsByCustomer(ctx context.Context, arg ListEventsByCustomerParams) ([]*Event, error) {
	rows, err := q.db.QueryContext(ctx, listEventsByCustomer, arg.CustomerID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.ServiceID,
			&i.UserID,
			&i.BrandID,
			&i.StartTime,
			&i.EndTime,
			&i.CustomerName,
			&i.ServiceName,
			&i.UserName,
			&i.Comment,
			&i.BufferTime,
			&i.Cost,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEventsByUser = `-- name: ListEventsByUser :many
SELECT id, customer_id, service_id, user_id, brand_id, start_time, end_time, customer_name, service_name, user_name, comment, buffer_time, cost, created_at, updated_at FROM events
WHERE user_id = $1
ORDER BY start_time
LIMIT $2
OFFSET $3
`

type ListEventsByUserParams struct {
	UserID int64 `json:"userId"`
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListEventsByUser(ctx context.Context, arg ListEventsByUserParams) ([]*Event, error) {
	rows, err := q.db.QueryContext(ctx, listEventsByUser, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.ServiceID,
			&i.UserID,
			&i.BrandID,
			&i.StartTime,
			&i.EndTime,
			&i.CustomerName,
			&i.ServiceName,
			&i.UserName,
			&i.Comment,
			&i.BufferTime,
			&i.Cost,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateEvent = `-- name: UpdateEvent :one
UPDATE events
SET
  customer_id = $2,
  service_id = $3,
  user_id = $4,
  brand_id = $5,
  start_time = $6,
  end_time = $7,
  comment = $8,
  customer_name = $9,
  service_name = $10,
  user_name = $11,
  cost = $12,
  buffer_time = $13,
  updated_at = NOW()
WHERE id = $1
RETURNING id, customer_id, service_id, user_id, brand_id, start_time, end_time, customer_name, service_name, user_name, comment, buffer_time, cost, created_at, updated_at
`

type UpdateEventParams struct {
	ID           int64          `json:"id"`
	CustomerID   int64          `json:"customerId"`
	ServiceID    uuid.UUID      `json:"serviceId"`
	UserID       int64          `json:"userId"`
	BrandID      int32          `json:"brandId"`
	StartTime    time.Time      `json:"startTime"`
	EndTime      time.Time      `json:"endTime"`
	Comment      sql.NullString `json:"comment"`
	CustomerName string         `json:"customerName"`
	ServiceName  string         `json:"serviceName"`
	UserName     string         `json:"userName"`
	Cost         sql.NullString `json:"cost"`
	BufferTime   sql.NullInt32  `json:"bufferTime"`
}

func (q *Queries) UpdateEvent(ctx context.Context, arg UpdateEventParams) (*Event, error) {
	row := q.db.QueryRowContext(ctx, updateEvent,
		arg.ID,
		arg.CustomerID,
		arg.ServiceID,
		arg.UserID,
		arg.BrandID,
		arg.StartTime,
		arg.EndTime,
		arg.Comment,
		arg.CustomerName,
		arg.ServiceName,
		arg.UserName,
		arg.Cost,
		arg.BufferTime,
	)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.ServiceID,
		&i.UserID,
		&i.BrandID,
		&i.StartTime,
		&i.EndTime,
		&i.CustomerName,
		&i.ServiceName,
		&i.UserName,
		&i.Comment,
		&i.BufferTime,
		&i.Cost,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}
