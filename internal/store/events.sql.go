// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: events.sql

package store

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const checkSpecificTimeslotAvailability = `-- name: CheckSpecificTimeslotAvailability :one
WITH service_info AS (
    SELECT s.duration, s.buffer_time
    FROM services s
    WHERE s.id = $4
)
SELECT
    COALESCE(
        NOT EXISTS (
            SELECT 1
            FROM events b
            WHERE b.user_id = $1
              AND (
                  (b.start_time < $2 AND b.end_time > $3)
                  OR (b.start_time < ($2 + (INTERVAL '1 minute' * si.buffer_time))
                      AND b.end_time > $3)
              )
        ),
        ($1 IS NULL)
    ) AS is_available
FROM service_info si
`

type CheckSpecificTimeslotAvailabilityParams struct {
	UserID    int64     `json:"userId"`
	EndTime   time.Time `json:"endTime"`
	StartTime time.Time `json:"startTime"`
	ServiceID uuid.UUID `json:"serviceId"`
}

func (q *Queries) CheckSpecificTimeslotAvailability(ctx context.Context, arg CheckSpecificTimeslotAvailabilityParams) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, checkSpecificTimeslotAvailability,
		arg.UserID,
		arg.EndTime,
		arg.StartTime,
		arg.ServiceID,
	)
	var is_available interface{}
	err := row.Scan(&is_available)
	return is_available, err
}

const createEvent = `-- name: CreateEvent :one
INSERT INTO events (
  customer_id,
  service_id,
  user_id,
  brand_id,
  start_time,
  end_time,
  comment,
  customer_name,
  service_name,
  user_name,
  created_at,
  updated_at
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, NOW(), NOW()
) RETURNING id, customer_id, service_id, user_id, brand_id, start_time, end_time, customer_name, service_name, user_name, comment, created_at, updated_at
`

type CreateEventParams struct {
	CustomerID   int64          `json:"customerId"`
	ServiceID    uuid.UUID      `json:"serviceId"`
	UserID       int64          `json:"userId"`
	BrandID      int32          `json:"brandId"`
	StartTime    time.Time      `json:"startTime"`
	EndTime      time.Time      `json:"endTime"`
	Comment      sql.NullString `json:"comment"`
	CustomerName string         `json:"customerName"`
	ServiceName  string         `json:"serviceName"`
	UserName     string         `json:"userName"`
}

func (q *Queries) CreateEvent(ctx context.Context, arg CreateEventParams) (*Event, error) {
	row := q.db.QueryRowContext(ctx, createEvent,
		arg.CustomerID,
		arg.ServiceID,
		arg.UserID,
		arg.BrandID,
		arg.StartTime,
		arg.EndTime,
		arg.Comment,
		arg.CustomerName,
		arg.ServiceName,
		arg.UserName,
	)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.ServiceID,
		&i.UserID,
		&i.BrandID,
		&i.StartTime,
		&i.EndTime,
		&i.CustomerName,
		&i.ServiceName,
		&i.UserName,
		&i.Comment,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const deleteEvent = `-- name: DeleteEvent :exec
DELETE FROM events
WHERE id = $1
`

func (q *Queries) DeleteEvent(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteEvent, id)
	return err
}

const getAvailableTimeslots = `-- name: GetAvailableTimeslots :many
WITH
service_info AS (
    SELECT s.id, s.duration, s.buffer_time
    FROM services s
    WHERE s.id = $1
),
daily_events AS (
    SELECT b.start_time, b.end_time, b.user_id
    FROM events b
    WHERE b.brand_id = $2
      AND DATE(b.start_time) = $3
),
staff AS (
    SELECT u.id
    FROM users u
    WHERE u.brand_id = $2
    AND u.verified = true
),
time_slots AS (
    SELECT
        generate_series(
            $3::date + $4::time,
            $3::date + $5::time,
            (INTERVAL '1 minute' * (SELECT duration FROM service_info))
        ) AS slot_start
),
service_slots AS (
    SELECT
        ts.slot_start,
        ts.slot_start + (INTERVAL '1 minute' * (SELECT duration FROM service_info)) AS slot_end,
        (SELECT buffer_time FROM service_info) AS buffer_time
    FROM time_slots ts
),
staff_availability AS (
    SELECT
        s.id AS user_id,
        ss.slot_start,
        ss.slot_end,
        CASE WHEN EXISTS (
            SELECT 1 FROM daily_events db
            WHERE db.user_id = s.id
              AND (
                  -- Overlapping condition
                  (db.start_time < ss.slot_end AND db.end_time > ss.slot_start)
                  -- Also consider buffer time after appointment
                  OR (db.start_time < (ss.slot_end + (INTERVAL '1 minute' * ss.buffer_time))
                      AND db.end_time > ss.slot_start)
              )
        ) THEN false ELSE true END AS is_available
    FROM staff s
    CROSS JOIN service_slots ss
)
SELECT
    slot_start,
    slot_end,
    ARRAY_AGG(user_id) AS available_staff_ids,
    COUNT(user_id) AS available_staff_count
FROM staff_availability
WHERE is_available = true
GROUP BY slot_start, slot_end
HAVING COUNT(user_id) > 0
ORDER BY slot_start
`

type GetAvailableTimeslotsParams struct {
	ServiceID uuid.UUID `json:"serviceId"`
	BrandID   int32     `json:"brandId"`
	Date      time.Time `json:"date"`
	StartTime time.Time `json:"startTime"`
	EndTime   time.Time `json:"endTime"`
}

type GetAvailableTimeslotsRow struct {
	SlotStart           int64       `json:"slotStart"`
	SlotEnd             int32       `json:"slotEnd"`
	AvailableStaffIds   interface{} `json:"availableStaffIds"`
	AvailableStaffCount int64       `json:"availableStaffCount"`
}

// Parameters: brand_id, date, service_id
// Get all events for the given date and brand
// Get all users (staff) for the brand
// Generate time slots for the day (e.g., every 15 min from 9am to 5pm)
// Apply service duration to get slot end times
// Check availability for each staff member and time slot
// Final available time slots with at least one available staff
func (q *Queries) GetAvailableTimeslots(ctx context.Context, arg GetAvailableTimeslotsParams) ([]*GetAvailableTimeslotsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAvailableTimeslots,
		arg.ServiceID,
		arg.BrandID,
		arg.Date,
		arg.StartTime,
		arg.EndTime,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetAvailableTimeslotsRow
	for rows.Next() {
		var i GetAvailableTimeslotsRow
		if err := rows.Scan(
			&i.SlotStart,
			&i.SlotEnd,
			&i.AvailableStaffIds,
			&i.AvailableStaffCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventByID = `-- name: GetEventByID :one
SELECT id, customer_id, service_id, user_id, brand_id, start_time, end_time, customer_name, service_name, user_name, comment, created_at, updated_at FROM events b WHERE id = $1
`

func (q *Queries) GetEventByID(ctx context.Context, id int64) (*Event, error) {
	row := q.db.QueryRowContext(ctx, getEventByID, id)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.ServiceID,
		&i.UserID,
		&i.BrandID,
		&i.StartTime,
		&i.EndTime,
		&i.CustomerName,
		&i.ServiceName,
		&i.UserName,
		&i.Comment,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getEventsByDay = `-- name: GetEventsByDay :many
SELECT id, customer_id, service_id, user_id, brand_id, start_time, end_time, customer_name, service_name, user_name, comment, created_at, updated_at
FROM events
WHERE DATE(start_time) = $1
AND brand_id = $2
ORDER BY start_time ASC
`

type GetEventsByDayParams struct {
	StartTime time.Time `json:"startTime"`
	BrandID   int32     `json:"brandId"`
}

func (q *Queries) GetEventsByDay(ctx context.Context, arg GetEventsByDayParams) ([]*Event, error) {
	rows, err := q.db.QueryContext(ctx, getEventsByDay, arg.StartTime, arg.BrandID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.ServiceID,
			&i.UserID,
			&i.BrandID,
			&i.StartTime,
			&i.EndTime,
			&i.CustomerName,
			&i.ServiceName,
			&i.UserName,
			&i.Comment,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventsByWeek = `-- name: GetEventsByWeek :many
SELECT id, customer_id, service_id, user_id, brand_id, start_time, end_time, customer_name, service_name, user_name, comment, created_at, updated_at
FROM events
WHERE DATE(start_time) BETWEEN $1 AND $2
AND brand_id = $3
ORDER BY start_time ASC
`

type GetEventsByWeekParams struct {
	StartDate time.Time `json:"startDate"`
	EndDate   time.Time `json:"endDate"`
	BrandID   int32     `json:"brandId"`
}

func (q *Queries) GetEventsByWeek(ctx context.Context, arg GetEventsByWeekParams) ([]*Event, error) {
	rows, err := q.db.QueryContext(ctx, getEventsByWeek, arg.StartDate, arg.EndDate, arg.BrandID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.ServiceID,
			&i.UserID,
			&i.BrandID,
			&i.StartTime,
			&i.EndTime,
			&i.CustomerName,
			&i.ServiceName,
			&i.UserName,
			&i.Comment,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserEventsByDay = `-- name: GetUserEventsByDay :many
SELECT id, customer_id, service_id, user_id, brand_id, start_time, end_time, customer_name, service_name, user_name, comment, created_at, updated_at
FROM events
WHERE DATE(start_time) = $1
AND brand_id = $2
AND user_id = $3
ORDER BY start_time ASC
`

type GetUserEventsByDayParams struct {
	StartTime time.Time `json:"startTime"`
	BrandID   int32     `json:"brandId"`
	UserID    int64     `json:"userId"`
}

func (q *Queries) GetUserEventsByDay(ctx context.Context, arg GetUserEventsByDayParams) ([]*Event, error) {
	rows, err := q.db.QueryContext(ctx, getUserEventsByDay, arg.StartTime, arg.BrandID, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.ServiceID,
			&i.UserID,
			&i.BrandID,
			&i.StartTime,
			&i.EndTime,
			&i.CustomerName,
			&i.ServiceName,
			&i.UserName,
			&i.Comment,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserEventsByWeek = `-- name: GetUserEventsByWeek :many
SELECT id, customer_id, service_id, user_id, brand_id, start_time, end_time, customer_name, service_name, user_name, comment, created_at, updated_at
FROM events
WHERE DATE(start_time) BETWEEN $1 AND $2
AND brand_id = $3
AND user_id = $4
ORDER BY start_time ASC
`

type GetUserEventsByWeekParams struct {
	StartDate time.Time `json:"startDate"`
	EndDate   time.Time `json:"endDate"`
	BrandID   int32     `json:"brandId"`
	UserID    int64     `json:"userId"`
}

func (q *Queries) GetUserEventsByWeek(ctx context.Context, arg GetUserEventsByWeekParams) ([]*Event, error) {
	rows, err := q.db.QueryContext(ctx, getUserEventsByWeek,
		arg.StartDate,
		arg.EndDate,
		arg.BrandID,
		arg.UserID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.ServiceID,
			&i.UserID,
			&i.BrandID,
			&i.StartTime,
			&i.EndTime,
			&i.CustomerName,
			&i.ServiceName,
			&i.UserName,
			&i.Comment,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEventsByBrand = `-- name: ListEventsByBrand :many
SELECT id, customer_id, service_id, user_id, brand_id, start_time, end_time, customer_name, service_name, user_name, comment, created_at, updated_at FROM events
WHERE brand_id = $1
ORDER BY start_time
LIMIT $2
OFFSET $3
`

type ListEventsByBrandParams struct {
	BrandID int32 `json:"brandId"`
	Limit   int32 `json:"limit"`
	Offset  int32 `json:"offset"`
}

func (q *Queries) ListEventsByBrand(ctx context.Context, arg ListEventsByBrandParams) ([]*Event, error) {
	rows, err := q.db.QueryContext(ctx, listEventsByBrand, arg.BrandID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.ServiceID,
			&i.UserID,
			&i.BrandID,
			&i.StartTime,
			&i.EndTime,
			&i.CustomerName,
			&i.ServiceName,
			&i.UserName,
			&i.Comment,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEventsByCustomer = `-- name: ListEventsByCustomer :many
SELECT id, customer_id, service_id, user_id, brand_id, start_time, end_time, customer_name, service_name, user_name, comment, created_at, updated_at FROM events
WHERE customer_id = $1
ORDER BY start_time
LIMIT $2
OFFSET $3
`

type ListEventsByCustomerParams struct {
	CustomerID int64 `json:"customerId"`
	Limit      int32 `json:"limit"`
	Offset     int32 `json:"offset"`
}

func (q *Queries) ListEventsByCustomer(ctx context.Context, arg ListEventsByCustomerParams) ([]*Event, error) {
	rows, err := q.db.QueryContext(ctx, listEventsByCustomer, arg.CustomerID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.ServiceID,
			&i.UserID,
			&i.BrandID,
			&i.StartTime,
			&i.EndTime,
			&i.CustomerName,
			&i.ServiceName,
			&i.UserName,
			&i.Comment,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEventsByUser = `-- name: ListEventsByUser :many
SELECT id, customer_id, service_id, user_id, brand_id, start_time, end_time, customer_name, service_name, user_name, comment, created_at, updated_at FROM events
WHERE user_id = $1
ORDER BY start_time
LIMIT $2
OFFSET $3
`

type ListEventsByUserParams struct {
	UserID int64 `json:"userId"`
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListEventsByUser(ctx context.Context, arg ListEventsByUserParams) ([]*Event, error) {
	rows, err := q.db.QueryContext(ctx, listEventsByUser, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.ServiceID,
			&i.UserID,
			&i.BrandID,
			&i.StartTime,
			&i.EndTime,
			&i.CustomerName,
			&i.ServiceName,
			&i.UserName,
			&i.Comment,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateEventDetails = `-- name: UpdateEventDetails :one
UPDATE events
SET service_id = $2,
    user_id = $3,
    start_time = $4,
    end_time = $5,
    comment = $6,
    updated_at = NOW()
WHERE id = $1
RETURNING id, customer_id, service_id, user_id, brand_id, start_time, end_time, customer_name, service_name, user_name, comment, created_at, updated_at
`

type UpdateEventDetailsParams struct {
	ID        int64          `json:"id"`
	ServiceID uuid.UUID      `json:"serviceId"`
	UserID    int64          `json:"userId"`
	StartTime time.Time      `json:"startTime"`
	EndTime   time.Time      `json:"endTime"`
	Comment   sql.NullString `json:"comment"`
}

func (q *Queries) UpdateEventDetails(ctx context.Context, arg UpdateEventDetailsParams) (*Event, error) {
	row := q.db.QueryRowContext(ctx, updateEventDetails,
		arg.ID,
		arg.ServiceID,
		arg.UserID,
		arg.StartTime,
		arg.EndTime,
		arg.Comment,
	)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.ServiceID,
		&i.UserID,
		&i.BrandID,
		&i.StartTime,
		&i.EndTime,
		&i.CustomerName,
		&i.ServiceName,
		&i.UserName,
		&i.Comment,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}
