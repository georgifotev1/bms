// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: bookings.sql

package store

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const checkSpecificTimeslotAvailability = `-- name: CheckSpecificTimeslotAvailability :one
WITH service_info AS (
    SELECT s.duration, s.buffer_time
    FROM services s
    WHERE s.id = $4
)
SELECT
    COALESCE(
        NOT EXISTS (
            SELECT 1
            FROM bookings b
            WHERE b.user_id = $1
              AND (
                  (b.start_time < $2 AND b.end_time > $3)
                  OR (b.start_time < ($2 + (INTERVAL '1 minute' * si.buffer_time))
                      AND b.end_time > $3)
              )
        ),
        ($1 IS NULL)
    ) AS is_available
FROM service_info si
`

type CheckSpecificTimeslotAvailabilityParams struct {
	UserID    int64     `json:"userId"`
	EndTime   time.Time `json:"endTime"`
	StartTime time.Time `json:"startTime"`
	ServiceID uuid.UUID `json:"serviceId"`
}

func (q *Queries) CheckSpecificTimeslotAvailability(ctx context.Context, arg CheckSpecificTimeslotAvailabilityParams) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, checkSpecificTimeslotAvailability,
		arg.UserID,
		arg.EndTime,
		arg.StartTime,
		arg.ServiceID,
	)
	var is_available interface{}
	err := row.Scan(&is_available)
	return is_available, err
}

const createBooking = `-- name: CreateBooking :one
INSERT INTO bookings (
  customer_id,
  service_id,
  user_id,
  brand_id,
  start_time,
  end_time,
  comment,
  created_at,
  updated_at
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, NOW(), NOW()
) RETURNING id, customer_id, service_id, user_id, brand_id, start_time, end_time, comment, created_at, updated_at
`

type CreateBookingParams struct {
	CustomerID int64          `json:"customerId"`
	ServiceID  uuid.UUID      `json:"serviceId"`
	UserID     int64          `json:"userId"`
	BrandID    int32          `json:"brandId"`
	StartTime  time.Time      `json:"startTime"`
	EndTime    time.Time      `json:"endTime"`
	Comment    sql.NullString `json:"comment"`
}

func (q *Queries) CreateBooking(ctx context.Context, arg CreateBookingParams) (*Booking, error) {
	row := q.db.QueryRowContext(ctx, createBooking,
		arg.CustomerID,
		arg.ServiceID,
		arg.UserID,
		arg.BrandID,
		arg.StartTime,
		arg.EndTime,
		arg.Comment,
	)
	var i Booking
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.ServiceID,
		&i.UserID,
		&i.BrandID,
		&i.StartTime,
		&i.EndTime,
		&i.Comment,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const deleteBooking = `-- name: DeleteBooking :exec
DELETE FROM bookings
WHERE id = $1
`

func (q *Queries) DeleteBooking(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteBooking, id)
	return err
}

const getActiveBookingsForUser = `-- name: GetActiveBookingsForUser :many
SELECT id, customer_id, service_id, user_id, brand_id, start_time, end_time, comment, created_at, updated_at
FROM bookings
WHERE user_id = $1
  AND start_time <= $2
  AND end_time >= $2
`

type GetActiveBookingsForUserParams struct {
	UserID    int64     `json:"userId"`
	StartTime time.Time `json:"startTime"`
}

func (q *Queries) GetActiveBookingsForUser(ctx context.Context, arg GetActiveBookingsForUserParams) ([]*Booking, error) {
	rows, err := q.db.QueryContext(ctx, getActiveBookingsForUser, arg.UserID, arg.StartTime)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Booking
	for rows.Next() {
		var i Booking
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.ServiceID,
			&i.UserID,
			&i.BrandID,
			&i.StartTime,
			&i.EndTime,
			&i.Comment,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAvailableTimeslots = `-- name: GetAvailableTimeslots :many
WITH
service_info AS (
    SELECT s.id, s.duration, s.buffer_time
    FROM services s
    WHERE s.id = $1
),
daily_bookings AS (
    SELECT b.start_time, b.end_time, b.user_id
    FROM bookings b
    WHERE b.brand_id = $2
      AND DATE(b.start_time) = $3
),
staff AS (
    SELECT u.id
    FROM users u
    WHERE u.brand_id = $2
    AND u.verified = true
),
time_slots AS (
    SELECT
        generate_series(
            $3::date + $4::time,
            $3::date + $5::time,
            (INTERVAL '1 minute' * (SELECT duration FROM service_info))
        ) AS slot_start
),
service_slots AS (
    SELECT
        ts.slot_start,
        ts.slot_start + (INTERVAL '1 minute' * (SELECT duration FROM service_info)) AS slot_end,
        (SELECT buffer_time FROM service_info) AS buffer_time
    FROM time_slots ts
),
staff_availability AS (
    SELECT
        s.id AS user_id,
        ss.slot_start,
        ss.slot_end,
        CASE WHEN EXISTS (
            SELECT 1 FROM daily_bookings db
            WHERE db.user_id = s.id
              AND (
                  -- Overlapping condition
                  (db.start_time < ss.slot_end AND db.end_time > ss.slot_start)
                  -- Also consider buffer time after appointment
                  OR (db.start_time < (ss.slot_end + (INTERVAL '1 minute' * ss.buffer_time))
                      AND db.end_time > ss.slot_start)
              )
        ) THEN false ELSE true END AS is_available
    FROM staff s
    CROSS JOIN service_slots ss
)
SELECT
    slot_start,
    slot_end,
    ARRAY_AGG(user_id) AS available_staff_ids,
    COUNT(user_id) AS available_staff_count
FROM staff_availability
WHERE is_available = true
GROUP BY slot_start, slot_end
HAVING COUNT(user_id) > 0
ORDER BY slot_start
`

type GetAvailableTimeslotsParams struct {
	ServiceID uuid.UUID `json:"serviceId"`
	BrandID   int32     `json:"brandId"`
	Date      time.Time `json:"date"`
	StartTime time.Time `json:"startTime"`
	EndTime   time.Time `json:"endTime"`
}

type GetAvailableTimeslotsRow struct {
	SlotStart           int64       `json:"slotStart"`
	SlotEnd             int32       `json:"slotEnd"`
	AvailableStaffIds   interface{} `json:"availableStaffIds"`
	AvailableStaffCount int64       `json:"availableStaffCount"`
}

// Parameters: brand_id, date, service_id
// Get all bookings for the given date and brand
// Get all users (staff) for the brand
// Generate time slots for the day (e.g., every 15 min from 9am to 5pm)
// Apply service duration to get slot end times
// Check availability for each staff member and time slot
// Final available time slots with at least one available staff
func (q *Queries) GetAvailableTimeslots(ctx context.Context, arg GetAvailableTimeslotsParams) ([]*GetAvailableTimeslotsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAvailableTimeslots,
		arg.ServiceID,
		arg.BrandID,
		arg.Date,
		arg.StartTime,
		arg.EndTime,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetAvailableTimeslotsRow
	for rows.Next() {
		var i GetAvailableTimeslotsRow
		if err := rows.Scan(
			&i.SlotStart,
			&i.SlotEnd,
			&i.AvailableStaffIds,
			&i.AvailableStaffCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBookingByID = `-- name: GetBookingByID :one
SELECT id, customer_id, service_id, user_id, brand_id, start_time, end_time, comment, created_at, updated_at FROM bookings b WHERE id = $1
`

func (q *Queries) GetBookingByID(ctx context.Context, id int64) (*Booking, error) {
	row := q.db.QueryRowContext(ctx, getBookingByID, id)
	var i Booking
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.ServiceID,
		&i.UserID,
		&i.BrandID,
		&i.StartTime,
		&i.EndTime,
		&i.Comment,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getBookingsByTimeRange = `-- name: GetBookingsByTimeRange :many
SELECT id, customer_id, service_id, user_id, brand_id, start_time, end_time, comment, created_at, updated_at FROM bookings
WHERE brand_id = $1
  AND start_time >= $2
  AND end_time <= $3
ORDER BY start_time
`

type GetBookingsByTimeRangeParams struct {
	BrandID   int32     `json:"brandId"`
	StartTime time.Time `json:"startTime"`
	EndTime   time.Time `json:"endTime"`
}

func (q *Queries) GetBookingsByTimeRange(ctx context.Context, arg GetBookingsByTimeRangeParams) ([]*Booking, error) {
	rows, err := q.db.QueryContext(ctx, getBookingsByTimeRange, arg.BrandID, arg.StartTime, arg.EndTime)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Booking
	for rows.Next() {
		var i Booking
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.ServiceID,
			&i.UserID,
			&i.BrandID,
			&i.StartTime,
			&i.EndTime,
			&i.Comment,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBookingsByBrand = `-- name: ListBookingsByBrand :many
SELECT id, customer_id, service_id, user_id, brand_id, start_time, end_time, comment, created_at, updated_at FROM bookings
WHERE brand_id = $1
ORDER BY start_time
LIMIT $2
OFFSET $3
`

type ListBookingsByBrandParams struct {
	BrandID int32 `json:"brandId"`
	Limit   int32 `json:"limit"`
	Offset  int32 `json:"offset"`
}

func (q *Queries) ListBookingsByBrand(ctx context.Context, arg ListBookingsByBrandParams) ([]*Booking, error) {
	rows, err := q.db.QueryContext(ctx, listBookingsByBrand, arg.BrandID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Booking
	for rows.Next() {
		var i Booking
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.ServiceID,
			&i.UserID,
			&i.BrandID,
			&i.StartTime,
			&i.EndTime,
			&i.Comment,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBookingsByCustomer = `-- name: ListBookingsByCustomer :many
SELECT id, customer_id, service_id, user_id, brand_id, start_time, end_time, comment, created_at, updated_at FROM bookings
WHERE customer_id = $1
ORDER BY start_time
LIMIT $2
OFFSET $3
`

type ListBookingsByCustomerParams struct {
	CustomerID int64 `json:"customerId"`
	Limit      int32 `json:"limit"`
	Offset     int32 `json:"offset"`
}

func (q *Queries) ListBookingsByCustomer(ctx context.Context, arg ListBookingsByCustomerParams) ([]*Booking, error) {
	rows, err := q.db.QueryContext(ctx, listBookingsByCustomer, arg.CustomerID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Booking
	for rows.Next() {
		var i Booking
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.ServiceID,
			&i.UserID,
			&i.BrandID,
			&i.StartTime,
			&i.EndTime,
			&i.Comment,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBookingsByUser = `-- name: ListBookingsByUser :many
SELECT id, customer_id, service_id, user_id, brand_id, start_time, end_time, comment, created_at, updated_at FROM bookings
WHERE user_id = $1
ORDER BY start_time
LIMIT $2
OFFSET $3
`

type ListBookingsByUserParams struct {
	UserID int64 `json:"userId"`
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListBookingsByUser(ctx context.Context, arg ListBookingsByUserParams) ([]*Booking, error) {
	rows, err := q.db.QueryContext(ctx, listBookingsByUser, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Booking
	for rows.Next() {
		var i Booking
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.ServiceID,
			&i.UserID,
			&i.BrandID,
			&i.StartTime,
			&i.EndTime,
			&i.Comment,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateBookingDetails = `-- name: UpdateBookingDetails :one
UPDATE bookings
SET service_id = $2,
    user_id = $3,
    start_time = $4,
    end_time = $5,
    comment = $6,
    updated_at = NOW()
WHERE id = $1
RETURNING id, customer_id, service_id, user_id, brand_id, start_time, end_time, comment, created_at, updated_at
`

type UpdateBookingDetailsParams struct {
	ID        int64          `json:"id"`
	ServiceID uuid.UUID      `json:"serviceId"`
	UserID    int64          `json:"userId"`
	StartTime time.Time      `json:"startTime"`
	EndTime   time.Time      `json:"endTime"`
	Comment   sql.NullString `json:"comment"`
}

func (q *Queries) UpdateBookingDetails(ctx context.Context, arg UpdateBookingDetailsParams) (*Booking, error) {
	row := q.db.QueryRowContext(ctx, updateBookingDetails,
		arg.ID,
		arg.ServiceID,
		arg.UserID,
		arg.StartTime,
		arg.EndTime,
		arg.Comment,
	)
	var i Booking
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.ServiceID,
		&i.UserID,
		&i.BrandID,
		&i.StartTime,
		&i.EndTime,
		&i.Comment,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}
