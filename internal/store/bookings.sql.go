// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: bookings.sql

package store

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const createBooking = `-- name: CreateBooking :one
INSERT INTO bookings (
    customer_id,
    service_id,
    user_id,
    brand_id,
    date,
    status_id,
    comment
) VALUES (
    $1, $2, $3, $4, $5,
    (SELECT status_id FROM booking_status WHERE status_name = $6),
    $7
)
RETURNING id, customer_id, service_id, user_id, brand_id, date, status_id, comment, created_at, updated_at
`

type CreateBookingParams struct {
	CustomerID int32          `json:"customerId"`
	ServiceID  uuid.UUID      `json:"serviceId"`
	UserID     sql.NullInt32  `json:"userId"`
	BrandID    int32          `json:"brandId"`
	Date       time.Time      `json:"date"`
	StatusName string         `json:"statusName"`
	Comment    sql.NullString `json:"comment"`
}

func (q *Queries) CreateBooking(ctx context.Context, arg CreateBookingParams) (*Booking, error) {
	row := q.db.QueryRowContext(ctx, createBooking,
		arg.CustomerID,
		arg.ServiceID,
		arg.UserID,
		arg.BrandID,
		arg.Date,
		arg.StatusName,
		arg.Comment,
	)
	var i Booking
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.ServiceID,
		&i.UserID,
		&i.BrandID,
		&i.Date,
		&i.StatusID,
		&i.Comment,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const deleteBooking = `-- name: DeleteBooking :exec
DELETE FROM bookings
WHERE
    id = $1
    AND brand_id = $2
`

type DeleteBookingParams struct {
	ID      int64 `json:"id"`
	BrandID int32 `json:"brandId"`
}

func (q *Queries) DeleteBooking(ctx context.Context, arg DeleteBookingParams) error {
	_, err := q.db.ExecContext(ctx, deleteBooking, arg.ID, arg.BrandID)
	return err
}

const getBookingByID = `-- name: GetBookingByID :one
SELECT
    b.id,
    b.customer_id,
    b.service_id,
    b.user_id,
    b.brand_id,
    b.date,
    bs.status_name,
    b.comment,
    b.created_at,
    b.updated_at
FROM
    bookings b
JOIN
    booking_status bs ON b.status_id = bs.status_id
WHERE
    b.id = $1
    AND b.brand_id = $2
`

type GetBookingByIDParams struct {
	ID      int64 `json:"id"`
	BrandID int32 `json:"brandId"`
}

type GetBookingByIDRow struct {
	ID         int64          `json:"id"`
	CustomerID int32          `json:"customerId"`
	ServiceID  uuid.UUID      `json:"serviceId"`
	UserID     sql.NullInt32  `json:"userId"`
	BrandID    int32          `json:"brandId"`
	Date       time.Time      `json:"date"`
	StatusName string         `json:"statusName"`
	Comment    sql.NullString `json:"comment"`
	CreatedAt  time.Time      `json:"createdAt"`
	UpdatedAt  time.Time      `json:"updatedAt"`
}

func (q *Queries) GetBookingByID(ctx context.Context, arg GetBookingByIDParams) (*GetBookingByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getBookingByID, arg.ID, arg.BrandID)
	var i GetBookingByIDRow
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.ServiceID,
		&i.UserID,
		&i.BrandID,
		&i.Date,
		&i.StatusName,
		&i.Comment,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getBookingsByBrand = `-- name: GetBookingsByBrand :many
SELECT
    b.id,
    b.customer_id,
    b.service_id,
    b.user_id,
    b.brand_id,
    b.date,
    bs.status_name,
    b.comment,
    b.created_at,
    b.updated_at
FROM
    bookings b
JOIN
    booking_status bs ON b.status_id = bs.status_id
WHERE
    b.brand_id = $1
ORDER BY
    b.date DESC
LIMIT $2
OFFSET $3
`

type GetBookingsByBrandParams struct {
	BrandID int32 `json:"brandId"`
	Limit   int32 `json:"limit"`
	Offset  int32 `json:"offset"`
}

type GetBookingsByBrandRow struct {
	ID         int64          `json:"id"`
	CustomerID int32          `json:"customerId"`
	ServiceID  uuid.UUID      `json:"serviceId"`
	UserID     sql.NullInt32  `json:"userId"`
	BrandID    int32          `json:"brandId"`
	Date       time.Time      `json:"date"`
	StatusName string         `json:"statusName"`
	Comment    sql.NullString `json:"comment"`
	CreatedAt  time.Time      `json:"createdAt"`
	UpdatedAt  time.Time      `json:"updatedAt"`
}

func (q *Queries) GetBookingsByBrand(ctx context.Context, arg GetBookingsByBrandParams) ([]*GetBookingsByBrandRow, error) {
	rows, err := q.db.QueryContext(ctx, getBookingsByBrand, arg.BrandID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetBookingsByBrandRow
	for rows.Next() {
		var i GetBookingsByBrandRow
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.ServiceID,
			&i.UserID,
			&i.BrandID,
			&i.Date,
			&i.StatusName,
			&i.Comment,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBookingsByDateRange = `-- name: GetBookingsByDateRange :many
SELECT
    b.id,
    b.customer_id,
    b.service_id,
    b.user_id,
    b.brand_id,
    b.date,
    bs.status_name,
    b.comment,
    b.created_at,
    b.updated_at
FROM
    bookings b
JOIN
    booking_status bs ON b.status_id = bs.status_id
WHERE
    b.brand_id = $1
    AND b.date BETWEEN $2 AND $3
ORDER BY
    b.date ASC
`

type GetBookingsByDateRangeParams struct {
	BrandID int32     `json:"brandId"`
	Date    time.Time `json:"date"`
	Date_2  time.Time `json:"date2"`
}

type GetBookingsByDateRangeRow struct {
	ID         int64          `json:"id"`
	CustomerID int32          `json:"customerId"`
	ServiceID  uuid.UUID      `json:"serviceId"`
	UserID     sql.NullInt32  `json:"userId"`
	BrandID    int32          `json:"brandId"`
	Date       time.Time      `json:"date"`
	StatusName string         `json:"statusName"`
	Comment    sql.NullString `json:"comment"`
	CreatedAt  time.Time      `json:"createdAt"`
	UpdatedAt  time.Time      `json:"updatedAt"`
}

func (q *Queries) GetBookingsByDateRange(ctx context.Context, arg GetBookingsByDateRangeParams) ([]*GetBookingsByDateRangeRow, error) {
	rows, err := q.db.QueryContext(ctx, getBookingsByDateRange, arg.BrandID, arg.Date, arg.Date_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetBookingsByDateRangeRow
	for rows.Next() {
		var i GetBookingsByDateRangeRow
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.ServiceID,
			&i.UserID,
			&i.BrandID,
			&i.Date,
			&i.StatusName,
			&i.Comment,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCustomerBookings = `-- name: GetCustomerBookings :many
SELECT
    b.id,
    b.customer_id,
    b.service_id,
    b.user_id,
    b.brand_id,
    b.date,
    bs.status_name,
    b.comment,
    b.created_at,
    b.updated_at
FROM
    bookings b
JOIN
    booking_status bs ON b.status_id = bs.status_id
WHERE
    b.customer_id = $1
    AND b.brand_id = $2
ORDER BY
    b.date DESC
LIMIT $3
OFFSET $4
`

type GetCustomerBookingsParams struct {
	CustomerID int32 `json:"customerId"`
	BrandID    int32 `json:"brandId"`
	Limit      int32 `json:"limit"`
	Offset     int32 `json:"offset"`
}

type GetCustomerBookingsRow struct {
	ID         int64          `json:"id"`
	CustomerID int32          `json:"customerId"`
	ServiceID  uuid.UUID      `json:"serviceId"`
	UserID     sql.NullInt32  `json:"userId"`
	BrandID    int32          `json:"brandId"`
	Date       time.Time      `json:"date"`
	StatusName string         `json:"statusName"`
	Comment    sql.NullString `json:"comment"`
	CreatedAt  time.Time      `json:"createdAt"`
	UpdatedAt  time.Time      `json:"updatedAt"`
}

func (q *Queries) GetCustomerBookings(ctx context.Context, arg GetCustomerBookingsParams) ([]*GetCustomerBookingsRow, error) {
	rows, err := q.db.QueryContext(ctx, getCustomerBookings,
		arg.CustomerID,
		arg.BrandID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetCustomerBookingsRow
	for rows.Next() {
		var i GetCustomerBookingsRow
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.ServiceID,
			&i.UserID,
			&i.BrandID,
			&i.Date,
			&i.StatusName,
			&i.Comment,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserBookingsByDateRange = `-- name: GetUserBookingsByDateRange :many
SELECT
    b.id,
    b.customer_id,
    b.service_id,
    b.user_id,
    b.brand_id,
    b.date,
    bs.status_name,
    b.comment,
    b.created_at,
    b.updated_at
FROM
    bookings b
JOIN
    booking_status bs ON b.status_id = bs.status_id
WHERE
    b.brand_id = $1
    AND b.user_id = $2
    AND b.date BETWEEN $3 AND $4
ORDER BY
    b.date ASC
`

type GetUserBookingsByDateRangeParams struct {
	BrandID int32         `json:"brandId"`
	UserID  sql.NullInt32 `json:"userId"`
	Date    time.Time     `json:"date"`
	Date_2  time.Time     `json:"date2"`
}

type GetUserBookingsByDateRangeRow struct {
	ID         int64          `json:"id"`
	CustomerID int32          `json:"customerId"`
	ServiceID  uuid.UUID      `json:"serviceId"`
	UserID     sql.NullInt32  `json:"userId"`
	BrandID    int32          `json:"brandId"`
	Date       time.Time      `json:"date"`
	StatusName string         `json:"statusName"`
	Comment    sql.NullString `json:"comment"`
	CreatedAt  time.Time      `json:"createdAt"`
	UpdatedAt  time.Time      `json:"updatedAt"`
}

func (q *Queries) GetUserBookingsByDateRange(ctx context.Context, arg GetUserBookingsByDateRangeParams) ([]*GetUserBookingsByDateRangeRow, error) {
	rows, err := q.db.QueryContext(ctx, getUserBookingsByDateRange,
		arg.BrandID,
		arg.UserID,
		arg.Date,
		arg.Date_2,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetUserBookingsByDateRangeRow
	for rows.Next() {
		var i GetUserBookingsByDateRangeRow
		if err := rows.Scan(
			&i.ID,
			&i.CustomerID,
			&i.ServiceID,
			&i.UserID,
			&i.BrandID,
			&i.Date,
			&i.StatusName,
			&i.Comment,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateBookingDetails = `-- name: UpdateBookingDetails :one
UPDATE bookings
SET
    date = COALESCE($2, date),
    user_id = COALESCE($3, user_id),
    comment = COALESCE($4, comment),
    updated_at = NOW()
WHERE
    id = $1
    AND brand_id = $5
RETURNING id, customer_id, service_id, user_id, brand_id, date, status_id, comment, created_at, updated_at
`

type UpdateBookingDetailsParams struct {
	ID      int64          `json:"id"`
	Date    time.Time      `json:"date"`
	UserID  sql.NullInt32  `json:"userId"`
	Comment sql.NullString `json:"comment"`
	BrandID int32          `json:"brandId"`
}

func (q *Queries) UpdateBookingDetails(ctx context.Context, arg UpdateBookingDetailsParams) (*Booking, error) {
	row := q.db.QueryRowContext(ctx, updateBookingDetails,
		arg.ID,
		arg.Date,
		arg.UserID,
		arg.Comment,
		arg.BrandID,
	)
	var i Booking
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.ServiceID,
		&i.UserID,
		&i.BrandID,
		&i.Date,
		&i.StatusID,
		&i.Comment,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const updateBookingStatus = `-- name: UpdateBookingStatus :one
UPDATE bookings
SET
    status_id = (SELECT status_id FROM booking_status WHERE status_name = $2),
    updated_at = NOW()
WHERE
    id = $1
    AND brand_id = $3
RETURNING id, customer_id, service_id, user_id, brand_id, date, status_id, comment, created_at, updated_at
`

type UpdateBookingStatusParams struct {
	ID         int64  `json:"id"`
	StatusName string `json:"statusName"`
	BrandID    int32  `json:"brandId"`
}

func (q *Queries) UpdateBookingStatus(ctx context.Context, arg UpdateBookingStatusParams) (*Booking, error) {
	row := q.db.QueryRowContext(ctx, updateBookingStatus, arg.ID, arg.StatusName, arg.BrandID)
	var i Booking
	err := row.Scan(
		&i.ID,
		&i.CustomerID,
		&i.ServiceID,
		&i.UserID,
		&i.BrandID,
		&i.Date,
		&i.StatusID,
		&i.Comment,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}
